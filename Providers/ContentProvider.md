# ContentProvider
Специальный "сервис", выделенный фреймворком android в отдельную категорию `provider`, который позволяет обращаться к заранее описанным данным, посредством URI ([Uniform Resource Identifier](https://ru.wikipedia.org/wiki/URI)) из разных приложений совместно.
Как правило **ContentProvider** используется в паре с базой данных например на **SQLite** (в моем текущем проекте я храню в SQLite кешированные данные запросов к серверу)

В статье "[Создание поставщика контента](https://developer.android.com/guide/topics/providers/content-provider-creating?hl=ru)" от Google Developers рекомендуется не использовать ContentProvider в ряде случаев:
>Вам не нужен поставщик для работы с базой данных SQLite, если ее планируется использовать исключительно в вашем приложении.

Итак, чтобы использовать **ContentProvider** нам необходимо определиться с его идентификатором и способом хранения данных (да, это не обязательно должна быть БД), т.к. **ContentProvider** штука используемая для взаимодействия разных приложений необходимо обеспечить уникальность его идентификатора, рекомендуется использовать имя пакета. например `com.example.appname.provider`
Далее следует прописать наш provider в файле манифеста
```xml
<provider
    android:authorities="com.dogvscat.monday.provider"
    android:name=".service.UsersContentProvider" />
```
Где - `authorities` и есть наш идентификатор.
Т.к. Основой запросов к ресурсам с ипользованием **ContentProvider** является URI вида `content://<authorities>/<content_path>`, нам необходимо продумать как мы назовем наши ресуры (в моем случае - таблицы БД), в строке URI имя таблицы `<content_path>`. Желательно сохранить `authorities` и имена таблиц в статические константы для удобства использования. 

Затем, нужно создать класс реализующий интерфейс базового класса ContentProvider и реализовать его методы **query()**, **insert()**, **update()**, **delete()**, **getType()**, **onCreate()** ([вот неплохая статья по созданию contentProvider на Java](http://developer.alexanderklimov.ru/android/theory/contentprovider.php)).
Все методы кроме **onCreate()** принимают на вход в качестве одного из параметров URI элемент. 

В процессе работы программы возможны разные сценарии использования данных, как правило нам необходимо работать или с конкретной записью или со всеми данными таблицы целиком, чтоб ContentProvider мог различить, какие данные ему передавать был придуман класс **UriMatcher** 
## UriMatcher
Он нужен чтобы "распарсить" наш URI на части и вернуть один из возможных сценариев использования (целочисленную константу), на примере кода это будет выглядеть следующим образом
```Kotlin
/**
 * Пример на Kotlin
 */
//Объявляем константы которые должен вернуть UriMatcher
 val URI_USERS = 1
 val URI_USERS_ID = 2
 val uriMatcher: UriMatcher = UriMatcher(UriMatcher.NO_MATCH)
    init {
//Здесь USER_PATH - имя таблицы
        uriMatcher.addURI(AUTHORITY, USER_PATH, URI_USERS)
        uriMatcher.addURI(AUTHORITY, "$USER_PATH/#", URI_USERS_ID)
    }
```
В примере указанном выше используется символ **#** - это символ подствновки указывающий, что на его месте возможно любое целое число, также допускется использовать символ **"*"**, который укажет на любую последовательность символов (как в регулярном выражении)
Использовать UriMatcher необходимо в реализациях методов **ContentProvider** для нашего **CustomContentProvider**, где в зависимости от передаваемого URI, UriMatcher вернет константу и нам останется включить switch/case и обратотать разные сценарии

##onCreate()
В этом методе нам необходимо проинициализировать наше хранилище данных (в моем случае создать БД)

##query
Запрос в БД

##insert
Вставка записи в БД

##delete
Удаление записи из БД

##update 
Изменение записи в БД

##getType
Возвращает MIME тип данных - нужно чтобы дать понять другим приложениям данные какого типа возвращает наш **ContentProvider**